#include <malloc.h>
#include <stdio.h>

int g; //2. статическая переменная для всех функций остаётся неизменной. Видимость там, где она описана.
static int g2; // g2 всё так же глобальная переменная, но уже в рамках одного файла. Другие файлы не увидят эту глобальную переменную
int f(int g) {
    //::g = 5; Работает в плюсах, но не в С
    static int s = 0;
    int x;
    s++;
    // Статическая переменная для метода выглядит как локальная, но живёт как глобальная.
    // Другими словами, глобальная переменная в рамках метода.
    // Можно, например, считать количество обращений к методу
}
//void ff(int k[3]) { // На самом деле это void ff(int *k) //IS IT MOTHERFUCKING JOJO REFERENCE?
//
//}

int main(void) {
    int z = 2;
    f(z);
    // Где можно, выделять передавать данные?
    // 1. Передаётся копия объекта как локальная переменная на стек переменных.
    // Но размер стека, куда передаются эти штуки, при рекурсии ограничен. Где-то 4гб, это грустно. А там и stackoverflow не далеко
    // 2. Секция данных. Выше написано. Ограничений глобальных переменных как таковых нет (около 1ГБ).
    // Но размер глобальной переменной должен быть известен (для массива например)
    // 3. Куча. heap (иф ю ар инглишмен).


    // Одномерные массивы
    int w = 4;
    //int a[w];
    int *a;
    a = malloc(sizeof(int) * w);
    // к указателю можно обращаться как к массиву a[0..3]. О разницах с обычными массивами будет позже
    // Выделили память под a и указатель ставится на начало массива. В С++, кстати, ещё придётся кастовать.
    // Но это уже беды религиозных фанатиков С++, об этом будет позже
    free(a); // null спокойно жрёт, кстати
    // Освобождаем память. Память нужно освобождать таким же способом, как его открывали.
    // Если открыли через malloc, освобождаем с помощью free. С другими открытиями free не подойдёт.

    // Двумерные массивы - это непрерывный блок памяти, котороый интерпретируется как двумерный массив. При этом строчки имеют одинаковый размер
    // Вычисляем указатель нужного элемента и один раз обращаемся к памяти

    // Массив массивов. У каждого массива в массиве есть свой указатель
    // Сначала находим указатель массива с нужным элементом, а затем обращаемся к нужному элементу из найденного массива. 2 обращения к памяти

    // int a[10][]; Подобное невалидно в С.
    // В массиве массивов удобно менять местами внутренние массивы, а вот в двумерном массиве не очень.
    // В первом случае ручками перекладываем все значения. А во втором случае нужно просто поменять местами два указателя на массивы.
    // Двумерный массив как одномерный. Работает везде.
    int h = 10, ww = 10;
    int *aa = malloc(sizeof(int) * h * ww);
    aa[5*w + 5] = 69; //обращение к a[5][5]

    // Для продвинутых компиляторов, так как не все поддерживают VLA
    int (*b)[ww] = malloc(sizeof(int) * h * ww);
    b[5][5] = 3;
    // VLArr - массивы переменной длины
    // VLA не может быть ни статическим, ни глобальным по понятным причинам. Это тип, данные о котором станут известны только во время компиляции
    // В плюсах нет VLA.
    printf("%lu\n", sizeof(char[5]));
    return 0;
}