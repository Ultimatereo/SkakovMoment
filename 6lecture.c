#include <stdbool.h>
#include <stdio.h>
#include <string.h>
size_t getLengthCharArray(const char* charArray) {
  for (size_t i = 0;;i++) {
    if (charArray[i] == 0) {
      return i;
    }
  }
}

size_t getLengthCharArray2(const char* charArray) {
  size_t x;
  for (x = 0; charArray[x]; x++);
  return x;
}
int main() {
  // Статические элементы по дефолту инициализируются нулём, а не мусором!
  // Статическую переменную видно в рамках метода, а глобальную внутри файла
  // Статическая глобальная переменная видна только в рамке одного файла
  const int x = 2; // Создали что-то, что поменять нельзя
  int a;
  const int b = 2;
  const int *p = &b; // Здесь есть глубокий смысол
  // штука, которая только считывает данные и никак не мог изменить то, что внутри

  p = &b; // p указатель на const int, поэтому *p = 0 не скомпилится
  p = &a; // *p = 0 до сих пор не компилится
  int * const q = &a; // константный указатель на int
  // q = ... не скомпилится
  *q = 3; // работает
  // int * const qq = &b; Происходит warning, что так делать нельзя. Понятно почему

  // Статическая библиотека компилится вместе с кодом и вставляется в код
  // dll - dynamic-link library
  // Мем в том, что если у программы есть зависимости от dll, то он просто подключает какие-то методы из dll динамически
  // Но если нет нужного dll файла, то очень грустно, мы проиграли, наш exe-шник не запустится
  // Есть ещё мемы с С-шными рантаймами при статической линковке с рантаймом, поэтому лучше линковаться динамически
  // То, что поставляется с системой, это системная библиотека. Они не только есть, но ещё и сложно заменяемы.
  int xxx = 2;
  short int xx = 2;
  float y = xx;
  y = xxx; // Warning, так как теряем точность при больших интах

  // Где всегда надо писать ручками приведение типа?
  // При маллоке в С++, об этом уже говорилось на прошлой лекции

  // String в С это просто массив символов
  // Как хранить размер строки. Хранить отдельно размер, но так в С не делается
  // Есть символ строки, чтобы понять размер строки. Так в С и делается
  // Например, "abc" это на самом деле массив из 'a', 'b', 'c', 0
  printf("%zu\n", getLengthCharArray("abc"));
  printf("%zu\n", getLengthCharArray(""));
  printf("%zu\n", getLengthCharArray2("abc"));
  printf("%zu\n", getLengthCharArray2(""));
  // Из стандарта есть strlen
  printf("%zu\n", strlen("abc"));
  printf("%zu\n", strlen(""));

  // Как печатать строчку?
  char xX[20];
  xX[0] = 'a';
  xX[1] = 'b';
  xX[2] = 'c';
  xX[3] = 0;
  xX[4] = 'l';
  printf("%s\n", xX);

  //А как читать?
  scanf("%19s", xX); //Считываем не более 19 символов, а если больше, то функция впадёт в отчаяние
  // scanf(%s) читает до пробела или табуляции
  printf("%s\n", xX);

  // Ещё есть fgets, fwrite, fread, но мы об этом не будем говорить

  sscanf(xX, "%i", &a); // StringReader, аналогично и с sprintf
  printf("%s %i\n", xX, a);
  // Ещё рассказали про argc и argv, но это и на курсе джавы было
  // Кодировки: КОИ-8, СР-866, СР-1251
  // DBCS - для японцев, китайцев и других людей с иероглифами
  // UCS - каждый символ 16 бит
  // UTF-16, UTF-32, UTF-8
  // Основная идея, если вы хотите всё поддерживать, то UTF-8 это ваш друг
}