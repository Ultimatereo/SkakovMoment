#include <stdio.h>

int main() {
    int a, b = 0, c; // a - not initialized, там мусор (не null, а какой-то мусор)
    a = b + 3;
    a += b;
    a = b = c;
    //(a = b) = c; Expression is not assignable, но в C++ будет работать,
    // так как в отличие от С возвращается объект, а не значение при присваивании
    //------------------
    b = a++; // b' = a, a' = a + 1
    b = ++a; // a' = b' = a + 1
    //------------------
    // Operators: + - * / %
    // - может быть операцией вычитания, если он используется в бинарных выражениях a = b - c
    // - может быть унарным минусом a = -b
    // Унарное * (звёздочка) влияет на указатель, а не перемножает числа.
    // Вообще у * три значения. Обычное, вот это и ещё одно, о котором будет позже
    // a = ---10; Ambiguous situation (так как есть - и --)
    c = (a++)+(++a); //  в одном выржении не надо писать
    // два инкремента к одной переменной!!! Не очень понятно, что выйдет в итоге
    // c = f() + g(), нет гарантий, что он скомпилит раньше f,
    // ~~поэтому используем подобное только с коммутативными операциями~~
    //------------------
    a = 7 / 3; //2 возвращает одинаковый тип операнда; округление к нулю
    a = -7 % 3; // b = -2; a / b * b + a%b -> a; результат -1
    //------------------

    unsigned int d = 10;
    unsigned int e = 5;
    d = e - d; //Есть неявное приведение???
    printf("%d", d);

    //a = 7 / 0 Undefined behaviour.
    //Ничего не гарантируется, может и упасть, может и не упасть Может и вывести что-то, а может и нет

    //------------------
    // Bit operators: & | ^
    a = 12 & 6; // 4
    //------------------
    // Logical operators: && ||
    // a = 12 && 6 // 1 Input: true (not 0) or false(0); Output: true (1) or false(0)
    // Logical inversion ! and побитовое не ~
    // !!a => boolean(a)
    //------------------
    //a & 1 == 1; // Интерпретируется как a & (1==1), к сожалению
    // (a & 1) = 1;
    // f() && g() работает как в java, сначала проверяется f, затем при необходимости g (сокращённые вычисления, это в стандарте)
    //------------------
    // Types:
    // int это целые числа с диапазоном не хуже -32767..32767
    // Реально получаем диапазон -2^31 .. 2^31 - 1
    // short int нечто не больше int, на деле -32768..3276
    // long int нечто не меньше int, на деле 32/64 бит (в разных системах ведёт себя по разному)
    // long long int нечто не меньше long int, на деле 64 бита
    // long long long int dd = 10; error: 'long long long' is too long for GCC
    // unsigned int Contains at least the [0, 65,535] range. На деле 0..2^32 - 1.
    // unsigned short int На деле 0..65535
    // Можно опустить int при наличии модификаций. unsigned short вместо unsigned short int
    typedef unsigned int 祡123;
    typedef int iпt;
    typedef unsigned int تكنيكية;
    iпt bruh = 42069;
    祡123 dd = 300;
    تكنيكية aa = -5;
    printf("\n%i\n", aa);
    // char 0..255 или -128..127. Не договорились( Поэтому лучше использовать signed char или unsigned char.
    // _Bool ещё есть. Но можно задефайнить как bool

//    for (int i = 5; i > 3; i++) {
//        i -= 10;
//    }
    //INT_MIN / -1 undefined behaviour
    int x = -100;
    unsigned int y = 100;
    if (x < 0) {
        y = x;
        y = -y;
    } else {
        y = x;
    }
    // Обратная косая черта как символ \\, иначе это что-то наподобие \n
    // В пути к файлу можно использовать прямую косую черту /
    b = 10;
    scanf("%i ,%i", &a, &b);
    printf("%i %i", a, b);


}
